<!DOCTYPE html>
<html><head lang="en">
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Threads - jpnt website</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="Pragmatic notes on threading concepts, APIs, and Linux implementation" />
	<meta property="og:image" content=""/>
	<meta property="og:url" content="https://jpnt.github.io/posts/threads/">
  <meta property="og:site_name" content="jpnt website">
  <meta property="og:title" content="Threads">
  <meta property="og:description" content="Pragmatic notes on threading concepts, APIs, and Linux implementation">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-11-06T00:55:09+00:00">
    <meta property="article:modified_time" content="2025-11-06T00:55:09+00:00">
    <meta property="article:tag" content="Systems">
    <meta property="article:tag" content="Concurrency">
    <meta property="article:tag" content="Linux">
    <meta property="article:tag" content="Os">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Threads">
  <meta name="twitter:description" content="Pragmatic notes on threading concepts, APIs, and Linux implementation">
<script src="https://jpnt.github.io/js/feather.min.js"></script>
	
	
        <link href="https://jpnt.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://jpnt.github.io/css/main.5cebd7d4fb2b97856af8d32a6def16164fcf7d844e98e236fcb3559655020373.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://jpnt.github.io/css/dark.d22e2a2879d933a4b781535fc4c4c716e9f9d35ea4986dd0cbabda82effc4bdd.css"   />
	

	
	

	
	

	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://jpnt.github.io/">jpnt website</a>
	</div>
	<nav>
		
		<a href="/">~/</a>
		
		<a href="/posts">posts</a>
		
		<a href="/about">about</a>
		
		<a href="/cv">cv</a>
		
		<a href="/quotes">quotes</a>
		
		<a href="/tags">tags</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">Threads</h1>
			<div class="meta">Posted on Nov 6, 2025</div>
		</div>
		

		

		<section class="body">
			<h1 id="context-and-brief-history">Context and brief history</h1>
<p>Before threads as we know them today, operating systems already supported concurrency using multiple processes and hardware interrupts.
We’re talking roughly about the period from the late 1950s to the 1980s, before the standardization of POSIX Threads (pthreads) in the 1990s.</p>
<p>Early systems like IBM OS/360 (1967), MULTICS (1969), and later UNIX Version 6 (1975) implemented multiprogramming: several independent processes could appear to run at once by time-slicing the CPU.
Each process had its own address space and execution context. The kernel saved and restored the CPU state when switching between them. This gave the illusion of parallelism on a single-core CPU.</p>
<p>At the hardware level, CPUs of that era executed one instruction stream per processor core, in program order, but still overlapped work using mechanisms like interrupts and direct memory access (DMA).
Interrupts allowed external devices or timers to temporarily suspend execution to handle events, and DMA let peripherals read or write memory without CPU intervention — limited forms of hardware concurrency.</p>
<p>Threads were introduced later (1980s onward, formalized by POSIX in the early 1990s) to provide fine-grained, low-overhead concurrency within a single process.
Unlike processes, threads share memory, file descriptors, and other resources directly, making communication and synchronization much cheaper.</p>
<h1 id="why-threads-what-threads-some-concepts-first">Why threads? What threads? Some concepts first</h1>
<p>A thread is a single sequence of execution within a process — the smallest schedulable unit of work in an operating system.
Each thread has its own register state, program counter, and stack, but shares the process’s address space, open files, and other resources.</p>
<p>The idea behind threads came from a practical need: reduce overhead and improve responsiveness.
Before threads, creating or switching between processes required a full context switch — saving and restoring all CPU state and changing the active memory mapping. This was relatively expensive, especially on systems that handled many concurrent tasks (for example, window managers, network servers, or database engines).</p>
<p>Threads make these cases cheaper because they:</p>
<ol>
<li>Avoid duplicating address spaces.</li>
<li>Avoid heavy inter-process communication (IPC) costs — all threads see the same memory.</li>
<li>Allow better latency hiding, e.g., one thread waiting on I/O while another continues computation.</li>
</ol>
<p>In short, threads were introduced to provide lightweight concurrency inside a single process, where tasks need to cooperate closely and share data freely.
They bridge the gap between full isolation (processes) and pure event-driven or asynchronous code by letting multiple control flows coexist in the same memory context.</p>
<p>At the kernel level, a thread is not magic. On Linux and most modern Unix-like systems, a “thread” is simply a task created with specific sharing flags (clone() with CLONE_VM, CLONE_FILES, and similar).
Each thread still has its own kernel stack and scheduling entry, but they all map to the same address space. The kernel scheduler doesn’t treat them differently from processes — only the sharing semantics differ.</p>
<p>From a system design perspective, threads trade safety for performance:</p>
<ol>
<li>They are cheaper to create and switch between.</li>
<li>They allow direct memory sharing.</li>
<li>But a bug in one thread (e.g., invalid pointer, race condition) can corrupt the entire process.</li>
</ol>
<p>TL;DR: A thread is a lightweight execution context within a process. It exists to make fine-grained parallelism and responsive design practical without the cost of full process isolation.</p>
<h1 id="processes-vs-threads">Processes vs Threads</h1>
<p>In UNIX-like systems, both processes and threads represent independent flows of execution.
The difference is what they share and what they isolate.</p>
<p>A process is an instance of a running program with its own:</p>
<ul>
<li>Address space (private virtual memory)</li>
<li>Global and static variables</li>
<li>Heap and stack</li>
<li>File descriptor table (copied from the parent at fork(), but independent afterward)</li>
<li>Signal handlers, PID, and other kernel metadata</li>
</ul>
<p>A thread, on the other hand, is a separate execution context within a process.
It has:</p>
<ul>
<li>Its own stack (for function calls, locals, return addresses)</li>
<li>Its own register state and thread-local storage (TLS)</li>
<li>But it shares everything else with its sibling threads:
<ul>
<li>Global and static variables</li>
<li>Heap memory</li>
<li>Open file descriptors</li>
<li>Signal dispositions (in most POSIX models)</li>
<li>The process ID (getpid() returns the same value for all threads)</li>
</ul>
</li>
</ul>
<h1 id="example-global-variables-and-shared-memory">Example: Global Variables and Shared Memory</h1>
<p>This is one of the key behavioral differences:</p>
<ul>
<li>In processes, global variables are copied on fork().</li>
</ul>
<p>After a fork(), the parent and child each have their own independent copy of every variable.
Modifying a global variable in the child does not affect the parent, because they live in separate address spaces.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">fork</span>() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    counter<span style="color:#f92672">++</span>; <span style="color:#75715e">// child changes its own copy
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    counter<span style="color:#f92672">--</span>; <span style="color:#75715e">// parent changes its own copy
</span></span></span></code></pre></div><ul>
<li>In threads, all globals are shared.</li>
</ul>
<p>Changing a global variable from one thread is visible to all threads in that process immediately.</p>
<p>int counter = 0;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">worker</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> arg) {
</span></span><span style="display:flex;"><span>    counter<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pthread_t</span> t;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_create</span>(<span style="color:#f92672">&amp;</span>t, NULL, worker, NULL);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_join</span>(t, NULL);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, counter); <span style="color:#75715e">// will print 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Because both the main thread and the worker thread share the same address space, counter is common to both.</p>
<p>This is why threads require synchronization primitives like:</p>
<ul>
<li>mutexes</li>
<li>condition variables</li>
<li>atomic operations</li>
</ul>
<p>&hellip; to prevent race conditions on shared data.</p>
<h1 id="deadlocks">Deadlocks</h1>
<p>A deadlock occurs when two or more threads are waiting indefinitely for each other to release resources.
The key property: cyclic waiting. Once a cycle exists, no thread can proceed.</p>
<p>For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">pthread_mutex_t</span> a <span style="color:#f92672">=</span> PTHREAD_MUTEX_INITIALIZER;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pthread_mutex_t</span> b <span style="color:#f92672">=</span> PTHREAD_MUTEX_INITIALIZER;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">t1</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>a);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>b);
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">t2</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>b);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>a);
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Both threads acquire one lock and wait forever for the other.</p>
<p>Avoiding deadlocks usually means enforcing lock ordering:
always acquire locks in a globally consistent order (e.g., alphabetically, by address, or by ID).</p>
<p>Other mitigations include:</p>
<ul>
<li>Use trylock() variants and timeouts.</li>
<li>Keep critical sections minimal.</li>
<li>Prefer lock-free algorithms when possible.</li>
</ul>
<h1 id="spinlocks">Spinlocks</h1>
<p>A spinlock is the simplest lock type.
Instead of putting a thread to sleep while waiting, it spins — repeatedly checking if the lock is available.
This wastes CPU cycles but avoids context-switch overhead, so it’s useful when:</p>
<p>Critical sections are short (microseconds).</p>
<p>The lock is used inside the kernel, where sleeping isn’t allowed (e.g., interrupt handlers).</p>
<p>In pthreads: pthread_spin_lock() / pthread_spin_unlock().</p>
<p>Typical kernel spinlock implementation pattern:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">__atomic_test_and_set</span>(<span style="color:#f92672">&amp;</span>lock, __ATOMIC_ACQUIRE))
</span></span><span style="display:flex;"><span>    ; <span style="color:#75715e">// busy-wait
</span></span></span></code></pre></div><p>TL;DR: Use spinlocks only for very short, non-blocking critical sections; Otherwise, they degrade throughput.</p>
<h1 id="readerwriter-locks">Reader/Writer Locks</h1>
<p>A reader/writer lock (also called a shared/exclusive lock) allows:</p>
<ul>
<li>Multiple readers to hold the lock simultaneously.</li>
<li>A single writer to hold it exclusively.</li>
</ul>
<p>Useful when reads are frequent and writes are rare, e.g., configuration tables, routing caches, metadata lookups.</p>
<p>POSIX provides pthread_rwlock_t:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">pthread_rwlock_t</span> rw <span style="color:#f92672">=</span> PTHREAD_RWLOCK_INITIALIZER;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pthread_rwlock_rdlock</span>(<span style="color:#f92672">&amp;</span>rw);  <span style="color:#75715e">// shared read access
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">pthread_rwlock_wrlock</span>(<span style="color:#f92672">&amp;</span>rw);  <span style="color:#75715e">// exclusive write access
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">pthread_rwlock_unlock</span>(<span style="color:#f92672">&amp;</span>rw);
</span></span></code></pre></div><p>Internally, the implementation tracks reader counts and a pending writer flag.
Writers typically have priority to avoid starvation.</p>
<p>TL;DR: Use reader/writer locks to improve read-heavy workloads; Do not use them if writes are frequent — they’ll serialize anyway.</p>
<p>Locks are coordination primitives to protect shared state.
Deadlocks arise from incorrect locking order; spinlocks trade CPU for latency; reader/writer locks trade simplicity for concurrency in read-heavy code.
Every real system (time correct) uses all three — depending on the performance and correctness balance required.</p>
<h1 id="thread-control">Thread Control</h1>
<p>Threads are not abstract entities. They’re concrete execution contexts managed by the kernel scheduler and created by system calls (clone() on Linux).
From user space, we control threads primarily through the POSIX Threads (pthreads) API.
Let’s cover their full lifecycle and map each function to what the kernel actually does.</p>
<p>Creating threads API:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;pthread.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pthread_create</span>(<span style="color:#66d9ef">pthread_t</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">restrict</span> <span style="color:#66d9ef">thread</span>,
</span></span><span style="display:flex;"><span>                  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">pthread_attr_t</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">restrict</span> attr,
</span></span><span style="display:flex;"><span>                  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>start_routine)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>),
</span></span><span style="display:flex;"><span>                  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">restrict</span> arg);
</span></span></code></pre></div><p>For thread termination, there are three standard ways a thread ends:</p>
<ol>
<li>Normal return from the start routine.</li>
<li>Explicit call to pthread_exit(void* retval).</li>
<li>Another thread calls pthread_cancel().</li>
</ol>
<p>When a thread terminates:</p>
<ul>
<li>Its return value or exit code is stored until another thread joins it.</li>
<li>Kernel deallocates the kernel stack and other thread-specific structures.</li>
<li>If it’s the last thread in the process, the entire process exits.</li>
</ul>
<p>For joining threads: pthread_join() waits for another thread to finish:</p>
<p>It blocks until the target thread terminates, then copies its exit status (if any).
The joining thread is responsible for cleanup; detached threads (see below) are auto-cleaned by the runtime.</p>
<p>A detached thread cleans up automatically when it exits — no need for pthread_join().</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">pthread_detach</span>(tid);
</span></span></code></pre></div><p>Internally, this sets the thread’s joinable flag to false. When it terminates, the runtime frees all resources immediately.
Once detached, you can’t join it later — the handle becomes meaningless after exit.</p>
<p>For cancellation: pthread_cancel() requests another thread to exit</p>
<p>It doesn’t forcibly kill it; it sends a cancellation request, and the target checks for it at “cancellation points” — e.g. read(), pthread_testcancel(), sleep().</p>
<p>Rule of thumb: Never rely on cancellation for cleanup. Use explicit signals or condition variables.</p>
<p>Thread IDs: A POSIX thread ID (pthread_t), valid only within its process or a kernel TID (Thread ID), visible via gettid() or /proc/self/task/<tid>.</p>
<p>getpid() returns the same value for all threads in a process (because its the same process).</p>
<p>gettid() returns a unique kernel ID per thread — used by the scheduler and visible in ps -eLf.</p>
<p>Scheduling and Priorities: Threads are scheduled the same way as processes. The kernel scheduler treats every thread as a task with its own priority and timeslice.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">pthread_setschedparam</span>(<span style="color:#a6e22e">pthread_self</span>(), SCHED_FIFO, <span style="color:#f92672">&amp;</span>param);
</span></span></code></pre></div><p>TL;DR: A thread’s lifetime is managed entirely in user space via pthread_* APIs, but its existence and scheduling are handled by the kernel as a normal task.
Threads are cheap to create, but not free — each one still has a kernel stack, scheduler entry, and system call overhead.</p>
<h1 id="linux-kernel-context">Linux kernel context</h1>
<p>In Linux, there is no such thing as a “thread object” separate from a process.</p>
<p>Everything is represented by the same structure:
<a href="https://elixir.bootlin.com/linux/v6.17.7/source/include/linux/sched.h#L816">struct task_struct</a></p>
<p>The task_struct is the central kernel representation of a schedulable entity — process or thread.
Below is a reduced version showing only the fields relevant to user-space threads.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> task_struct {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* scheduling / execution context */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pid_t</span>           pid;        <span style="color:#75715e">/* unique kernel thread ID */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pid_t</span>           tgid;       <span style="color:#75715e">/* thread group ID (process ID) */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm;       <span style="color:#75715e">/* memory descriptor (NULL for kernel threads) */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> files_struct <span style="color:#f92672">*</span>files; <span style="color:#75715e">/* open file table */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> fs_struct    <span style="color:#f92672">*</span>fs;    <span style="color:#75715e">/* filesystem info: cwd, root */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* signal handling */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> signal_struct <span style="color:#f92672">*</span>signal; <span style="color:#75715e">/* shared signal handlers */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* thread group leader and siblings */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>group_leader;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* kernel stack pointer, architecture context etc */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> thread_info thread_info;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* scheduling linkage, priority etc */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* ... many other members omitted ... */</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>This structure represents a schedulable entity — what the kernel calls a task.</p>
<p>User-space pthread_create() eventually calls the system call: clone(flags, stack, ptid, ctid, tls)</p>
<h1 id="everything-is-a-thread">&ldquo;Everything is a thread&rdquo;</h1>
<p>Linux doesn’t maintain separate code for “process creation” and “thread creation.”</p>
<p>All user tasks are created by clone().</p>
<p>The only thing that changes is the degree of resource sharing.</p>
<p>That’s why the kernel community often says:</p>
<p>“Everything in Linux is a thread; fork() is just a clone() with fewer flags.”</p>
<p>This unification simplifies scheduling, accounting, and namespace management — all tasks are equal citizens in the scheduler, regardless of whether they’re “threads” or “processes.”</p>
<h1 id="threads-in-gui-applications">Threads in GUI applications</h1>
<p>Graphical applications often use threads to keep the user interface responsive.
The main thread runs the event loop (handling input, drawing, etc.), while worker threads perform blocking or long-running tasks such as file I/O, network requests, or background computation.</p>
<p>The typical model is this:</p>
<ul>
<li>Main/UI thread – owns all GUI state and must never block.</li>
<li>Worker threads – handle heavy or asynchronous work, then notify the main thread (via signals, message queues, or atomic flags).</li>
</ul>
<p>Most GUI toolkits — GTK, Qt, Cocoa, Win32 — enforce that all UI operations must occur in the main thread.</p>
<p>This prevents race conditions in windowing subsystems that are not thread-safe.</p>
<p>So, GUI applications use threads for isolation of work, not for parallel rendering.
Responsiveness first, throughput second.</p>
<h1 id="virtual-threads">Virtual threads</h1>
<p>&ldquo;Virtual threads&rdquo; refer to threads implemented mostly in user space, not directly as kernel tasks.</p>
<p>For example:</p>
<ul>
<li>Go goroutines</li>
<li>Java Project Loom</li>
<li>Rusts async tasks (using executors)</li>
</ul>
<p>They multiplex many user-space execution contexts over a smaller pool of kernel threads.</p>
<p>The kernel only sees the physical threads; scheduling between virtual ones happens in user land.</p>
<p>But why?</p>
<ol>
<li>Lower creation and context-switch cost.</li>
<li>Scales to hundreds of thousands of concurrent tasks.</li>
<li>Fits workloads dominated by I/O wait (not CPU).</li>
</ol>
<p>So&hellip; why not?</p>
<ol>
<li>No true parallelism without multiple kernel threads.</li>
<li>Blocking system calls stall the entire physical thread.</li>
<li>Complex runtime scheduler and stack management.</li>
</ol>
<h1 id="conclusion">Conclusion</h1>
<p>It&rsquo;s all trade-offs — user-space scheduling vs kernel scheduling, scalability vs transparency.
There&rsquo;s no universally perfect model. Choose the best tool for the job based on requirements and objetives.</p>
<h2 id="resources">Resources</h2>
<p>[1] W. R. Stevens, S. A. Rago, Advanced Programming in the UNIX Environment, 3rd ed., Addison-Wesley Professional, 2013.</p>
<p>[2] M. Kerrisk, The Linux Programming Interface: A Linux and UNIX System Programming Handbook, No Starch Press, 2010.</p>
<p>[3] R. Love, Linux Kernel Development, 3rd ed., Addison-Wesley Professional, 2010.</p>
<p>[4] Lawrence Livermore National Laboratory, “POSIX Threads Tutorial,” [Online]. Available: <a href="https://hpc-tutorials.llnl.gov/posix/">https://hpc-tutorials.llnl.gov/posix/</a></p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/systems">systems</a></li>
					
					<li><a href="/tags/concurrency">concurrency</a></li>
					
					<li><a href="/tags/linux">linux</a></li>
					
					<li><a href="/tags/os">os</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		</article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/jpnt" rel="me" title="GitHub"><i data-feather="github"></i></a>
    <a class="border"></a><a class="soc" href="https://jpnt.github.io/index.xml" rel="me" title="RSS Feed"><i data-feather="rss"></i></a>
    <a class="border"></a><a class="soc" href="https://www.linkedin.com/in/jpgpinto/" rel="me" title="LinkedIn"><i data-feather="linkedin"></i></a>
    <a class="border"></a></div>
  <div class="footer-info">
    2025  © João Pinto |  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


<script>
  feather.replace()
</script></div>
    </body>
</html>
